<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Exterior Product - Geometric Algebra</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #f5f5f7;
            min-height: 100vh;
            padding: 20px 10px;
            overflow-y: auto;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            overflow: hidden;
            margin-bottom: 20px;
        }

        .header {
            background: linear-gradient(135deg, #1d1d1f 0%, #3a3a3c 100%);
            color: white;
            padding: 24px;
            text-align: center;
        }

        h1 {
            font-size: clamp(1.4rem, 5vw, 1.8rem);
            margin-bottom: 6px;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: clamp(0.9rem, 3vw, 1rem);
            opacity: 0.7;
        }

        .mode-toggle {
            display: flex;
            gap: 0;
            margin-top: 16px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 4px;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }

        .mode-toggle button {
            flex: 1;
            padding: 10px;
            border: none;
            background: transparent;
            color: rgba(255,255,255,0.7);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .mode-toggle button.active {
            background: white;
            color: #1d1d1f;
        }

        .viz-container {
            position: relative;
            width: 100%;
            min-height: 500px;
            background: #ffffff;
            border-bottom: 1px solid #e5e5e7;
        }

        #canvas2d, #container3d {
            width: 100%;
            height: 500px;
            display: block;
        }

        #canvas2d {
            cursor: grab;
        }

        #canvas2d:active {
            cursor: grabbing;
        }

        #container3d {
            display: none;
            position: relative;
        }

        #container3d canvas {
            display: block;
            width: 100% !important;
            height: 500px !important;
        }

        .controls {
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        button {
            padding: 12px 20px;
            border: 1.5px solid #d2d2d7;
            background: white;
            color: #1d1d1f;
            border-radius: 10px;
            font-size: clamp(0.85rem, 2.5vw, 0.95rem);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #f5f5f7;
            border-color: #86868b;
        }

        button.active {
            background: #1d1d1f;
            color: white;
        }

        .info-panel {
            background: #f5f5f7;
            padding: 16px;
            border-radius: 10px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }

        .info-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e5e5e7;
        }

        .info-label {
            font-size: 0.8rem;
            color: #86868b;
            margin-bottom: 4px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .info-value {
            font-size: 1.4rem;
            font-weight: 600;
            color: #1d1d1f;
        }

        .explanation-panel {
            background: linear-gradient(135deg, #f5f7fa 0%, #f0f2f5 100%);
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            padding: 20px;
            margin: 16px 0;
            line-height: 1.6;
        }

        .explanation-panel h3 {
            margin: 0 0 12px 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #1d1d1f;
        }

        .explanation-panel p {
            margin: 8px 0;
            color: #1d1d1f;
            font-size: 0.95rem;
        }

        .explanation-panel strong {
            color: #007AFF;
            font-weight: 600;
        }

        .explanation-panel ul {
            margin: 8px 0;
            padding-left: 24px;
        }

        .explanation-panel li {
            margin: 6px 0;
            color: #1d1d1f;
            font-size: 0.9rem;
        }

        .explanation-panel .physics-examples {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            border-left: 3px solid #34C759;
        }

        .explanation-panel .physics-examples h4 {
            margin: 0 0 8px 0;
            font-size: 0.95rem;
            font-weight: 600;
            color: #34C759;
        }

        .explanation-2d {
            display: block;
        }

        .explanation-3d {
            display: none;
        }

        .instructions {
            background: #fff9e6;
            border: 1px solid #f0e5c5;
            border-radius: 10px;
            padding: 14px;
            font-size: 0.9rem;
            color: #6e5f3c;
            line-height: 1.5;
        }

        .instructions strong {
            display: block;
            margin-bottom: 6px;
            font-size: 0.95rem;
            color: #4a3f2a;
        }

        .education {
            background: #f5f5f7;
            padding: 32px 24px;
        }

        .education h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #1d1d1f;
            font-weight: 600;
        }

        .concept {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            border-left: 4px solid #007AFF;
        }

        .concept h3 {
            font-size: 1.1rem;
            margin-bottom: 12px;
            color: #1d1d1f;
            font-weight: 600;
        }

        .concept p {
            line-height: 1.6;
            color: #3a3a3c;
            margin-bottom: 12px;
        }

        .concept ul {
            list-style: none;
            padding: 0;
        }

        .concept li {
            padding: 8px 0 8px 24px;
            position: relative;
            color: #3a3a3c;
        }

        .concept li:before {
            content: "â†’";
            position: absolute;
            left: 0;
            color: #007AFF;
            font-weight: bold;
        }

        .formula {
            background: #f5f5f7;
            padding: 12px 16px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 12px 0;
            font-size: 0.95rem;
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .header {
                padding: 18px;
            }

            .controls, .education {
                padding: 16px;
            }

            .button-group {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Exterior Product Visualization</h1>
            <p class="subtitle">Interactive geometric algebra</p>
            <div class="mode-toggle">
                <button class="dimension-btn active" data-mode="2d">2D Bivector</button>
                <button class="dimension-btn" data-mode="3d">3D Trivector</button>
            </div>
        </div>

        <div class="viz-container">
            <canvas id="canvas2d" width="800" height="500"></canvas>
            <div id="container3d"></div>
        </div>

        <div class="controls">
            <div class="instructions">
                <strong id="instructionTitle">How to use (2D Mode)</strong>
                <span id="instructionText">Drag the circular endpoints to adjust vectors u and v. The bivector and orientation arrow update in real-time.</span>
            </div>

            <!-- 2D Bivector Explanation -->
            <div class="explanation-panel explanation-2d" id="explanation2d">
                <h3>ðŸ”· What is a Bivector?</h3>
                <p>A <strong>bivector</strong> (u âˆ§ v) represents an <strong>oriented area element</strong> â€” a parallelogram with a direction.</p>
                <p><strong>Key Properties:</strong></p>
                <ul>
                    <li><strong>Magnitude</strong> = Area of parallelogram = |u| |v| sin(Î¸)</li>
                    <li><strong>Orientation</strong> = Direction of rotation from u to v (counterclockwise â†» or clockwise â†º)</li>
                    <li><strong>Antisymmetry</strong>: Reversing order flips sign: v âˆ§ u = âˆ’(u âˆ§ v)</li>
                </ul>

                <div class="physics-examples">
                    <h4>âš¡ Physical Phenomena</h4>
                    <ul style="margin: 4px 0; padding-left: 20px;">
                        <li><strong>Angular Momentum:</strong> L = r âˆ§ p (position âˆ§ momentum)</li>
                        <li><strong>Torque:</strong> Ï„ = r âˆ§ F (lever arm âˆ§ force)</li>
                        <li><strong>Magnetic Flux:</strong> Î¦ = B âˆ§ A (field âˆ§ area element)</li>
                        <li><strong>Rotational Planes:</strong> Bivectors represent the plane of rotation</li>
                    </ul>
                </div>
            </div>

            <!-- 3D Trivector Explanation -->
            <div class="explanation-panel explanation-3d" id="explanation3d">
                <h3>ðŸ”¶ What is a Trivector?</h3>
                <p>A <strong>trivector</strong> (u âˆ§ v âˆ§ w) represents an <strong>oriented volume element</strong> â€” a parallelepiped with a handedness.</p>
                <p><strong>Key Properties:</strong></p>
                <ul>
                    <li><strong>Magnitude</strong> = Volume of parallelepiped = |u Â· (v Ã— w)|</li>
                    <li><strong>Orientation</strong> = Handedness (right-handed + or left-handed âˆ’)</li>
                    <li><strong>Decomposition</strong>: Each face shows a bivector component (uâˆ§v, uâˆ§w, vâˆ§w)</li>
                    <li><strong>Dual arrows</strong>: Positive (inner, blue/orange) vs negative (outer, red/green)</li>
                </ul>

                <div class="physics-examples">
                    <h4>âš¡ Physical Phenomena</h4>
                    <ul style="margin: 4px 0; padding-left: 20px;">
                        <li><strong>Volume Flow:</strong> Fluid flux through 3D regions</li>
                        <li><strong>Triple Products:</strong> Scalar triple product in mechanics</li>
                        <li><strong>Determinants:</strong> Volume scaling in linear transformations</li>
                        <li><strong>Spacetime Volumes:</strong> In relativity, 4D volume elements</li>
                        <li><strong>Circulation:</strong> Each face shows circulation in that plane</li>
                    </ul>
                </div>
            </div>

            <div class="button-group" id="operationButtons">
                <button class="mode-btn active" data-mode="u^v">u âˆ§ v</button>
                <button class="mode-btn" data-mode="v^u">v âˆ§ u</button>
                <button class="mode-btn" data-mode="-u^v">âˆ’u âˆ§ v</button>
                <button class="mode-btn" data-mode="-v^u">âˆ’v âˆ§ u</button>
            </div>

            <div class="info-panel">
                <div class="info-label" style="font-weight: 600; margin-bottom: 10px; font-size: 0.85rem;">Properties</div>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label" id="magnitudeLabel">Area</div>
                        <div class="info-value" id="magnitude">0.00</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Orientation</div>
                        <div class="info-value" id="orientation" style="font-size: 1.1rem;">â€”</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Expression</div>
                        <div class="info-value" id="expression" style="font-size: 1.1rem;">u âˆ§ v</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="education">
            <h2>Understanding Exterior Products</h2>

            <div class="concept">
                <h3>ðŸ”· Bivectors (2 Vectors)</h3>
                <p>A bivector represents an <strong>oriented area element</strong> formed by two vectors.</p>
                <div class="formula">u âˆ§ v = oriented parallelogram area</div>
                <ul>
                    <li><strong>Magnitude:</strong> |u âˆ§ v| = |u| |v| sin(Î¸) â€” the area of the parallelogram</li>
                    <li><strong>Orientation:</strong> CCW (+) or CW (âˆ’) indicating the "handedness" of rotation</li>
                    <li><strong>Anticommutativity:</strong> v âˆ§ u = âˆ’(u âˆ§ v) â€” order matters!</li>
                </ul>

                <p><strong>Physics Connection:</strong></p>
                <ul>
                    <li><strong>Angular momentum:</strong> L = r âˆ§ p (position wedge momentum)</li>
                    <li><strong>Torque:</strong> Ï„ = r âˆ§ F (position wedge force)</li>
                    <li><strong>Magnetic flux:</strong> Î¦ = B âˆ§ A (field wedge area)</li>
                    <li><strong>Rotation:</strong> Bivectors naturally represent planes of rotation</li>
                </ul>
            </div>

            <div class="concept" style="border-left-color: #FF9500;">
                <h3>ðŸ”¶ Trivectors (3 Vectors)</h3>
                <p>A trivector represents an <strong>oriented volume element</strong> formed by three vectors.</p>
                <div class="formula">u âˆ§ v âˆ§ w = oriented parallelepiped volume</div>
                <ul>
                    <li><strong>Magnitude:</strong> |u âˆ§ v âˆ§ w| = |u Â· (v Ã— w)| â€” the volume</li>
                    <li><strong>Orientation:</strong> Right-handed (+) or left-handed (âˆ’)</li>
                    <li><strong>Cyclic property:</strong> u âˆ§ v âˆ§ w = v âˆ§ w âˆ§ u = w âˆ§ u âˆ§ v</li>
                </ul>

                <p><strong>Physics Connection:</strong></p>
                <ul>
                    <li><strong>Volume flux:</strong> In fluid dynamics, volume flow rates</li>
                    <li><strong>Triple products:</strong> Natural representation of scalar triple product</li>
                    <li><strong>3D rotations:</strong> Combinations of oriented planes</li>
                    <li><strong>Space-time:</strong> In relativity, 4-vectors form spacetime volumes</li>
                </ul>
            </div>

            <div class="concept" style="border-left-color: #34C759;">
                <h3>âš¡ Why This Matters in Physics</h3>
                <p>Geometric algebra provides a unified framework for understanding physical quantities:</p>
                <ul>
                    <li><strong>Natural representation:</strong> Physical quantities have geometric meaning (areas, volumes, rotations)</li>
                    <li><strong>Coordinate-free:</strong> Describes physics without arbitrary coordinate systems</li>
                    <li><strong>Unified operations:</strong> Dot product, cross product, and more emerge naturally</li>
                    <li><strong>Rotation & orientation:</strong> Bivectors encode rotation planes directly</li>
                    <li><strong>Maxwell's equations:</strong> Can be written as a single equation in GA</li>
                    <li><strong>Quantum mechanics:</strong> Spinors emerge naturally from geometric algebra</li>
                </ul>
            </div>

            <div class="concept" style="border-left-color: #FF3B30;">
                <h3>ðŸŽ¯ The Big Picture</h3>
                <p>The exterior product (âˆ§) builds up geometric objects:</p>
                <ul>
                    <li><strong>0-blade:</strong> Scalars (numbers)</li>
                    <li><strong>1-blade:</strong> Vectors (directed line segments)</li>
                    <li><strong>2-blade:</strong> Bivectors (oriented areas/planes)</li>
                    <li><strong>3-blade:</strong> Trivectors (oriented volumes)</li>
                </ul>
                <p>This hierarchy mirrors how physical quantities naturally combine and transform, making geometric algebra particularly powerful for physics, engineering, and computer graphics.</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============= MODE MANAGEMENT =============
        let currentMode = '2d';
        const canvas2d = document.getElementById('canvas2d');
        const container3d = document.getElementById('container3d');

        // ============= 2D BIVECTOR CODE =============
        const ctx = canvas2d.getContext('2d');

        function resizeCanvas() {
            if (currentMode !== '2d') return;
            const container = canvas2d.parentElement;
            const rect = container.getBoundingClientRect();
            canvas2d.width = rect.width;
            canvas2d.height = 500;
        }

        let state2d = {
            u: { x: 2, y: 0.7 },
            v: { x: 0.7, y: 2 },
            mode: 'u^v',
            dragging: null,
            arrowRotation: 0
        };

        function getScale() {
            return Math.min(canvas2d.width, canvas2d.height) * 0.12;
        }

        const VECTOR_RADIUS = 15;

        function getCenter() {
            return { x: canvas2d.width / 2, y: canvas2d.height / 2 };
        }

        function canvasToVector(canvasX, canvasY) {
            const center = getCenter();
            const scale = getScale();
            return {
                x: (canvasX - center.x) / scale,
                y: -(canvasY - center.y) / scale
            };
        }

        function vectorToCanvas(vec) {
            const center = getCenter();
            const scale = getScale();
            return {
                x: center.x + vec.x * scale,
                y: center.y - vec.y * scale
            };
        }

        function getInputPosition(e) {
            const rect = canvas2d.getBoundingClientRect();
            const scaleX = canvas2d.width / rect.width;
            const scaleY = canvas2d.height / rect.height;
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function isNearPoint(px, py, vec) {
            const canvasPos = vectorToCanvas(vec);
            const dx = px - canvasPos.x;
            const dy = py - canvasPos.y;
            return Math.sqrt(dx*dx + dy*dy) < VECTOR_RADIUS;
        }

        function calculateWedge() {
            let u = state2d.u;
            let v = state2d.v;

            if (state2d.mode === 'v^u') {
                [u, v] = [v, u];
            } else if (state2d.mode === '-u^v') {
                u = { x: -u.x, y: -u.y };
            } else if (state2d.mode === '-v^u') {
                v = { x: -v.x, y: -v.y };
                [u, v] = [v, u];
            }

            const cross = u.x * v.y - u.y * v.x;
            return {
                magnitude: Math.abs(cross),
                sign: Math.sign(cross),
                u: u,
                v: v
            };
        }

        function drawSmoothArrow(centerX, centerY, radius, clockwise, color) {
            const startAngle = state2d.arrowRotation;
            const arcLength = Math.PI * 1.5;
            const endAngle = startAngle + (clockwise ? -arcLength : arcLength);

            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 5;
            ctx.globalAlpha = 0.12;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, endAngle, clockwise);
            ctx.stroke();

            ctx.lineWidth = 2.5;
            ctx.globalAlpha = 1.0;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, endAngle, clockwise);
            ctx.stroke();

            const arrowX = centerX + radius * Math.cos(endAngle);
            const arrowY = centerY + radius * Math.sin(endAngle);
            const tangentAngle = endAngle + (clockwise ? Math.PI/2 : -Math.PI/2);

            const headLength = 12;
            const headWidth = 7;

            ctx.fillStyle = color;
            ctx.globalAlpha = 1.0;
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(
                arrowX - headLength * Math.cos(tangentAngle) + headWidth * Math.sin(tangentAngle),
                arrowY - headLength * Math.sin(tangentAngle) - headWidth * Math.cos(tangentAngle)
            );
            ctx.lineTo(
                arrowX - headLength * Math.cos(tangentAngle) - headWidth * Math.sin(tangentAngle),
                arrowY - headLength * Math.sin(tangentAngle) + headWidth * Math.cos(tangentAngle)
            );
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawVectorArrow(fromX, fromY, toX, toY, color, width = 3) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const headLength = 14;
            const headWidth = 8;

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle) + headWidth * Math.sin(angle),
                toY - headLength * Math.sin(angle) - headWidth * Math.cos(angle)
            );
            ctx.lineTo(
                toX - headLength * Math.cos(angle) - headWidth * Math.sin(angle),
                toY - headLength * Math.sin(angle) + headWidth * Math.cos(angle)
            );
            ctx.closePath();
            ctx.fill();
        }

        function draw2d() {
            if (currentMode !== '2d') return;

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas2d.width, canvas2d.height);

            const center = getCenter();
            const wedge = calculateWedge();
            const u = wedge.u;
            const v = wedge.v;

            ctx.strokeStyle = '#f5f5f7';
            ctx.lineWidth = 1;
            const gridSize = getScale();
            for (let x = 0; x < canvas2d.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas2d.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas2d.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas2d.width, y);
                ctx.stroke();
            }

            ctx.strokeStyle = '#d2d2d7';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(0, center.y);
            ctx.lineTo(canvas2d.width, center.y);
            ctx.moveTo(center.x, 0);
            ctx.lineTo(center.x, canvas2d.height);
            ctx.stroke();

            const uCanvas = vectorToCanvas(u);
            const vCanvas = vectorToCanvas(v);
            const sumCanvas = vectorToCanvas({ x: u.x + v.x, y: u.y + v.y });

            const isPositive = wedge.sign > 0;
            const faceColor = isPositive ? 'rgba(0, 122, 255, 0.12)' : 'rgba(255, 149, 0, 0.12)';
            const edgeColor = isPositive ? '#007AFF' : '#FF9500';
            const arrowColor = isPositive ? '#0051D5' : '#E67700';

            ctx.fillStyle = faceColor;
            ctx.strokeStyle = edgeColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(uCanvas.x, uCanvas.y);
            ctx.lineTo(sumCanvas.x, sumCanvas.y);
            ctx.lineTo(vCanvas.x, vCanvas.y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(uCanvas.x, uCanvas.y);
            ctx.lineTo(sumCanvas.x, sumCanvas.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(vCanvas.x, vCanvas.y);
            ctx.lineTo(sumCanvas.x, sumCanvas.y);
            ctx.stroke();
            ctx.setLineDash([]);

            drawVectorArrow(center.x, center.y, uCanvas.x, uCanvas.y, '#FF3B30', 3);
            drawVectorArrow(center.x, center.y, vCanvas.x, vCanvas.y, '#34C759', 3);

            ctx.font = '600 16px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const uAngle = Math.atan2(u.y, u.x);
            const vAngle = Math.atan2(v.y, v.x);
            const labelDist = 22;
            const uLabelX = uCanvas.x + labelDist * Math.cos(uAngle + Math.PI/2);
            const uLabelY = uCanvas.y - labelDist * Math.sin(uAngle + Math.PI/2);
            const vLabelX = vCanvas.x + labelDist * Math.cos(vAngle + Math.PI/2);
            const vLabelY = vCanvas.y - labelDist * Math.sin(vAngle + Math.PI/2);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.beginPath();
            ctx.arc(uLabelX, uLabelY, 11, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(vLabelX, vLabelY, 11, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FF3B30';
            ctx.fillText('u', uLabelX, uLabelY);
            ctx.fillStyle = '#34C759';
            ctx.fillText('v', vLabelX, vLabelY);

            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';

            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#FF3B30';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.arc(uCanvas.x, uCanvas.y, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.strokeStyle = '#34C759';
            ctx.beginPath();
            ctx.arc(vCanvas.x, vCanvas.y, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            const scale = getScale();
            const paraCenterX = center.x + (u.x + v.x) * scale / 2;
            const paraCenterY = center.y - (u.y + v.y) * scale / 2;
            const arrowRadius = Math.min(
                Math.sqrt(u.x*u.x + u.y*u.y),
                Math.sqrt(v.x*v.x + v.y*v.y)
            ) * scale * 0.28;

            drawSmoothArrow(paraCenterX, paraCenterY, arrowRadius, !isPositive, arrowColor);

            document.getElementById('magnitude').textContent = wedge.magnitude.toFixed(2);
            document.getElementById('orientation').textContent = isPositive ? 'CCW (+)' : 'CW (âˆ’)';
            document.getElementById('expression').textContent = state2d.mode.replace('^', ' âˆ§ ').replace('-', 'âˆ’');

            const rotationSpeed = isPositive ? 0.012 : -0.012;
            state2d.arrowRotation += rotationSpeed;

            requestAnimationFrame(draw2d);
        }

        // 2D Event handlers
        function handleStart(e) {
            if (currentMode !== '2d') return;
            e.preventDefault();
            const pos = getInputPosition(e);

            if (isNearPoint(pos.x, pos.y, state2d.u)) {
                state2d.dragging = 'u';
                canvas2d.style.cursor = 'grabbing';
            } else if (isNearPoint(pos.x, pos.y, state2d.v)) {
                state2d.dragging = 'v';
                canvas2d.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            if (currentMode !== '2d') return;
            e.preventDefault();
            const pos = getInputPosition(e);

            if (state2d.dragging) {
                const vec = canvasToVector(pos.x, pos.y);
                const mag = Math.sqrt(vec.x*vec.x + vec.y*vec.y);
                const maxMag = 6;
                if (mag > maxMag) {
                    vec.x = (vec.x / mag) * maxMag;
                    vec.y = (vec.y / mag) * maxMag;
                }
                state2d[state2d.dragging] = vec;
            } else {
                if (isNearPoint(pos.x, pos.y, state2d.u) || isNearPoint(pos.x, pos.y, state2d.v)) {
                    canvas2d.style.cursor = 'grab';
                } else {
                    canvas2d.style.cursor = 'default';
                }
            }
        }

        function handleEnd(e) {
            if (currentMode !== '2d') return;
            e.preventDefault();
            state2d.dragging = null;
            canvas2d.style.cursor = 'default';
        }

        canvas2d.addEventListener('mousedown', handleStart);
        canvas2d.addEventListener('mousemove', handleMove);
        canvas2d.addEventListener('mouseup', handleEnd);
        canvas2d.addEventListener('mouseleave', handleEnd);
        canvas2d.addEventListener('touchstart', handleStart, { passive: false });
        canvas2d.addEventListener('touchmove', handleMove, { passive: false });
        canvas2d.addEventListener('touchend', handleEnd, { passive: false });

        // ============= 3D TRIVECTOR CODE =============
        let scene, camera, renderer, vectors3d, parallelepiped, spinningArrows, spheres3d;
        let raycaster, mouse3d, isRotating3d = false, previousMouse = { x: 0, y: 0 };
        let dragging3d = null;
        let vectorLabels = { u: null, v: null, w: null };
        let faceLabels = [];
        let state3d = {
            u: new THREE.Vector3(2.5, 0.5, 0.3),
            v: new THREE.Vector3(0.5, 2.5, 0.8),
            w: new THREE.Vector3(0.3, 0.8, 2.0),
            mode: 'uvw',
            rotationAngle: 0
        };

        // Helper function to create text sprite
        function createTextSprite(text, color = '#ffffff', fontSize = 64, backgroundOpacity = 0.4) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;

            // More transparent background
            context.fillStyle = `rgba(0, 0, 0, ${backgroundOpacity})`;
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = `bold ${fontSize}px Arial`;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(1.2, 0.6, 1);  // Smaller than before

            return sprite;
        }

        // Create color-coded bivector label showing both positive and negative
        function createBivectorLabelSprite(bivectorName, positiveColor, negativeColor, fontSize = 48) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 256;

            // Transparent background
            context.fillStyle = 'rgba(0, 0, 0, 0.25)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = `bold ${fontSize}px Arial`;
            context.textBaseline = 'middle';

            // Measure text to center it
            const posText = bivectorName;
            const separator = ' / ';
            const negText = `âˆ’${bivectorName}`;

            context.fillStyle = positiveColor;
            const posWidth = context.measureText(posText).width;
            const sepWidth = context.measureText(separator).width;
            context.fillStyle = negativeColor;
            const negWidth = context.measureText(negText).width;

            const totalWidth = posWidth + sepWidth + negWidth;
            const startX = (canvas.width - totalWidth) / 2;

            // Draw positive component in its color
            context.fillStyle = positiveColor;
            context.textAlign = 'left';
            context.fillText(posText, startX, canvas.height / 2);

            // Draw separator in white
            context.fillStyle = '#ffffff';
            context.fillText(separator, startX + posWidth, canvas.height / 2);

            // Draw negative component in its color
            context.fillStyle = negativeColor;
            context.fillText(negText, startX + posWidth + sepWidth, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 0.5, 1);

            return sprite;
        }

        function init3D() {
            try {
                console.log('Initializing 3D mode...');

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);

                const rect = container3d.getBoundingClientRect();
                console.log('Container rect:', rect);

                camera = new THREE.PerspectiveCamera(50, rect.width / 500, 0.1, 1000);
                camera.position.set(8, 6, 8);
                camera.lookAt(0, 0, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(rect.width, 500);
                renderer.setPixelRatio(window.devicePixelRatio);
                container3d.appendChild(renderer.domElement);

                console.log('Renderer created and appended');

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(5, 10, 7);
                scene.add(directionalLight);

                const gridHelper = new THREE.GridHelper(10, 10, 0xd2d2d7, 0xf5f5f7);
                scene.add(gridHelper);
                const axesHelper = new THREE.AxesHelper(5);
                scene.add(axesHelper);

                vectors3d = { u: null, v: null, w: null };
                spheres3d = { u: null, v: null, w: null };
                spinningArrows = [];
                raycaster = new THREE.Raycaster();
                mouse3d = new THREE.Vector2();

                createVectors3D();
                createParallelepiped3D();

                console.log('3D scene created successfully');

                // Event listeners
                renderer.domElement.addEventListener('mousedown', on3DMouseDown);
                renderer.domElement.addEventListener('mousemove', on3DMouseMove);
                renderer.domElement.addEventListener('mouseup', on3DMouseUp);
                renderer.domElement.addEventListener('wheel', on3DWheel, { passive: false });
                renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

                renderer.domElement.addEventListener('touchstart', on3DTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', on3DTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', on3DTouchEnd, { passive: false });

                // Do an initial render
                renderer.render(scene, camera);
            } catch (error) {
                console.error('Error initializing 3D:', error);
                alert('Error initializing 3D mode: ' + error.message);
            }
        }

        function createVectors3D() {
            // Remove old objects
            Object.values(vectors3d).forEach(obj => obj && scene.remove(obj));
            Object.values(spheres3d).forEach(obj => obj && scene.remove(obj));
            Object.values(vectorLabels).forEach(obj => obj && scene.remove(obj));

            const createArrow = (dir, color) => {
                const arrow = new THREE.ArrowHelper(
                    dir.clone().normalize(),
                    new THREE.Vector3(0, 0, 0),
                    dir.length(),
                    color,
                    0.4,
                    0.3
                );
                return arrow;
            };

            vectors3d.u = createArrow(state3d.u, 0xFF3B30);
            vectors3d.v = createArrow(state3d.v, 0x34C759);
            vectors3d.w = createArrow(state3d.w, 0x007AFF);

            scene.add(vectors3d.u);
            scene.add(vectors3d.v);
            scene.add(vectors3d.w);

            // Add vector labels - no background, positioned beyond endpoints
            vectorLabels.u = createTextSprite('u', '#FF3B30', 72, 0);  // 0 = no background
            vectorLabels.u.position.copy(state3d.u.clone().multiplyScalar(1.15));  // 15% beyond tip
            scene.add(vectorLabels.u);

            vectorLabels.v = createTextSprite('v', '#34C759', 72, 0);  // 0 = no background
            vectorLabels.v.position.copy(state3d.v.clone().multiplyScalar(1.15));  // 15% beyond tip
            scene.add(vectorLabels.v);

            vectorLabels.w = createTextSprite('w', '#007AFF', 72, 0);  // 0 = no background
            vectorLabels.w.position.copy(state3d.w.clone().multiplyScalar(1.15));  // 15% beyond tip
            scene.add(vectorLabels.w);

            // Create draggable spheres at endpoints
            const sphereGeom = new THREE.SphereGeometry(0.2, 16, 16);

            spheres3d.u = new THREE.Mesh(
                sphereGeom,
                new THREE.MeshPhongMaterial({ color: 0xFF3B30 })
            );
            spheres3d.u.position.copy(state3d.u);
            spheres3d.u.userData = { vector: 'u' };
            scene.add(spheres3d.u);

            spheres3d.v = new THREE.Mesh(
                sphereGeom,
                new THREE.MeshPhongMaterial({ color: 0x34C759 })
            );
            spheres3d.v.position.copy(state3d.v);
            spheres3d.v.userData = { vector: 'v' };
            scene.add(spheres3d.v);

            spheres3d.w = new THREE.Mesh(
                sphereGeom,
                new THREE.MeshPhongMaterial({ color: 0x007AFF })
            );
            spheres3d.w.position.copy(state3d.w);
            spheres3d.w.userData = { vector: 'w' };
            scene.add(spheres3d.w);
        }

        function createParallelepiped3D() {
            if (parallelepiped) {
                scene.remove(parallelepiped);
            }
            spinningArrows.forEach(arrow => scene.remove(arrow));
            spinningArrows = [];
            faceLabels.forEach(label => scene.remove(label));
            faceLabels = [];

            const [vec1, vec2, vec3] = getOrderedVectors3D();
            const triple = vec1.dot(new THREE.Vector3().crossVectors(vec2, vec3));
            const isPositive = triple > 0;

            const geometry = new THREE.BufferGeometry();
            const origin = new THREE.Vector3(0, 0, 0);
            const p1 = vec1.clone();
            const p2 = vec2.clone();
            const p3 = vec3.clone();
            const p4 = new THREE.Vector3().addVectors(vec1, vec2);
            const p5 = new THREE.Vector3().addVectors(vec1, vec3);
            const p6 = new THREE.Vector3().addVectors(vec2, vec3);
            const p7 = new THREE.Vector3().addVectors(vec1, vec2).add(vec3);

            const vertices = new Float32Array([
                origin.x, origin.y, origin.z,
                p1.x, p1.y, p1.z,
                p4.x, p4.y, p4.z,
                p2.x, p2.y, p2.z,
                p3.x, p3.y, p3.z,
                p5.x, p5.y, p5.z,
                p7.x, p7.y, p7.z,
                p6.x, p6.y, p6.z
            ]);

            const indices = new Uint16Array([
                0,1,2, 0,2,3,  // Bottom
                4,5,6, 4,6,7,  // Top
                0,1,5, 0,5,4,  // Front
                2,3,7, 2,7,6,  // Back
                0,3,7, 0,7,4,  // Left
                1,2,6, 1,6,5   // Right
            ]);

            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({
                color: isPositive ? 0x7B9FD4 : 0xD47B7B,
                transparent: true,
                opacity: 0.25,  // More transparent
                side: THREE.DoubleSide
            });

            parallelepiped = new THREE.Mesh(geometry, material);
            scene.add(parallelepiped);

            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({
                    color: isPositive ? 0x007AFF : 0xFF9500,
                    linewidth: 2
                })
            );
            parallelepiped.add(line);

            // Create spinning arrows on ALL 6 faces with arrowheads
            // Colors now determined per-face based on bivector sign

            // Define all 6 faces with their corner points and edges
            const faces = [
                {
                    name: 'bottom',
                    corners: [origin, p1, p4, p2],
                    edge1: vec1,
                    edge2: vec2,
                    bivectorName: 'u âˆ§ v'
                },
                {
                    name: 'top',
                    corners: [p3, p5, p7, p6],
                    edge1: vec1,
                    edge2: vec2,
                    bivectorName: 'u âˆ§ v'
                },
                {
                    name: 'front',
                    corners: [origin, p1, p5, p3],
                    edge1: vec1,
                    edge2: vec3,
                    bivectorName: 'u âˆ§ w'
                },
                {
                    name: 'back',
                    corners: [p2, p4, p7, p6],
                    edge1: vec1,
                    edge2: vec3,
                    bivectorName: 'u âˆ§ w'
                },
                {
                    name: 'left',
                    corners: [origin, p2, p6, p3],
                    edge1: vec2,
                    edge2: vec3,
                    bivectorName: 'v âˆ§ w'
                },
                {
                    name: 'right',
                    corners: [p1, p4, p7, p5],
                    edge1: vec2,
                    edge2: vec3,
                    bivectorName: 'v âˆ§ w'
                }
            ];

            faces.forEach(face => {
                // Calculate face center
                const center = new THREE.Vector3();
                face.corners.forEach(p => center.add(p));
                center.divideScalar(4);

                // Calculate face normal (perpendicular to face)
                const normal = new THREE.Vector3().crossVectors(face.edge1, face.edge2).normalize();

                // Create BOTH positive and negative arrows on each face
                // bivectorSign: +1 for positive, -1 for negative
                [1, -1].forEach((bivectorSign, index) => {
                    // Determine circulation direction
                    const circulationDirection = (isPositive ? 1 : -1) * bivectorSign;

                    // Choose arrow color based on bivector sign
                    let arrowColor, arrowOpacity;
                    if (bivectorSign > 0) {
                        // Positive component - solid
                        arrowColor = isPositive ? 0x0051D5 : 0xE67700;  // Blue or Orange
                        arrowOpacity = 1.0;
                    } else {
                        // Negative component - semi-transparent
                        arrowColor = isPositive ? 0xFF3B30 : 0x34C759;  // Red or Green
                        arrowOpacity = 0.7;
                    }

                    // Create arrow group
                    const arrowGroup = new THREE.Group();

                    // Smaller radius to fit two arrows
                    const baseRadius = Math.min(face.edge1.length(), face.edge2.length()) * 0.2;

                    // Offset: inner (positive) vs outer (negative)
                    const radiusOffset = bivectorSign > 0 ? -0.15 : 0.15;
                    const radius = baseRadius + radiusOffset;
                    const tube = 0.035;  // Thinner tubes

                    // Create partial torus
                    const arcLength = Math.PI * 1.5;
                    const torusGeometry = new THREE.TorusGeometry(radius, tube, 8, 32, arcLength);
                    const torusMaterial = new THREE.MeshPhongMaterial({
                        color: arrowColor,
                        transparent: true,
                        opacity: arrowOpacity,
                        depthTest: false  // Always visible through cube
                    });
                    const torus = new THREE.Mesh(torusGeometry, torusMaterial);

                    // Flip if circulation is negative
                    if (circulationDirection < 0) {
                        torus.rotation.x = Math.PI;
                    }

                    arrowGroup.add(torus);

                    // Create arrowhead
                    const endAngle = circulationDirection > 0 ? arcLength : 0;
                    const arrowheadX = radius * Math.cos(endAngle);
                    const arrowheadY = radius * Math.sin(endAngle);
                    const tangentAngle = endAngle + (circulationDirection * Math.PI / 2);

                    const coneHeight = 0.15;
                    const coneRadius = 0.08;
                    const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 8);
                    const coneMaterial = new THREE.MeshPhongMaterial({
                        color: arrowColor,
                        transparent: true,
                        opacity: arrowOpacity,
                        depthTest: false  // Always visible through cube
                    });
                    const cone = new THREE.Mesh(coneGeometry, coneMaterial);

                    cone.position.x = arrowheadX;
                    cone.position.y = arrowheadY;
                    cone.position.z = 0;
                    cone.rotation.z = tangentAngle - Math.PI / 2;

                    arrowGroup.add(cone);

                    // Position at face center
                    arrowGroup.position.copy(center);

                    // Orient to face plane
                    const defaultNormal = new THREE.Vector3(0, 0, 1);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(defaultNormal, normal);
                    arrowGroup.quaternion.copy(quaternion);

                    // Store data for animation
                    arrowGroup.userData = {
                        isArrow: true,
                        isPositive,
                        faceName: face.name,
                        normal: normal.clone(),
                        baseQuaternion: quaternion.clone(),
                        rotationAxis: normal.clone(),
                        circulationDirection: circulationDirection,
                        bivectorSign: bivectorSign
                    };

                    scene.add(arrowGroup);
                    spinningArrows.push(arrowGroup);
                });

                // Add color-coded label showing both bivector names
                // Determine colors based on first arrow created (bivectorSign = 1)
                const positiveColor = isPositive ? '#0051D5' : '#E67700';  // Blue or Orange
                const negativeColor = isPositive ? '#FF3B30' : '#34C759';  // Red or Green

                const faceLabel = createBivectorLabelSprite(
                    face.bivectorName,
                    positiveColor,
                    negativeColor,
                    48
                );
                const labelOffset = normal.clone().multiplyScalar(0.35);
                faceLabel.position.copy(center.clone().add(labelOffset));
                scene.add(faceLabel);
                faceLabels.push(faceLabel);
            });

            document.getElementById('magnitude').textContent = Math.abs(triple).toFixed(2);
            document.getElementById('orientation').textContent = isPositive ? 'Right (+)' : 'Left (âˆ’)';
            document.getElementById('expression').textContent = 'u âˆ§ v âˆ§ w';
        }

        function getOrderedVectors3D() {
            if (state3d.mode === 'uvw') return [state3d.u, state3d.v, state3d.w];
            if (state3d.mode === 'vuw') return [state3d.v, state3d.u, state3d.w];
            return [state3d.w, state3d.v, state3d.u];
        }

        function updateVector3D(vectorName, newPosition) {
            state3d[vectorName].copy(newPosition);

            // Limit magnitude
            const mag = state3d[vectorName].length();
            const maxMag = 5;
            if (mag > maxMag) {
                state3d[vectorName].normalize().multiplyScalar(maxMag);
            }

            createVectors3D();
            createParallelepiped3D();
        }

        function animate3D() {
            if (currentMode !== '3d' || !renderer || !scene || !camera) {
                return;
            }

            try {
                state3d.rotationAngle += 0.015;

                spinningArrows.forEach(arrowGroup => {
                    // Use the stored circulation direction for this face
                    const direction = arrowGroup.userData.circulationDirection;

                    // Reset to base orientation (arrow lying in face plane)
                    arrowGroup.quaternion.copy(arrowGroup.userData.baseQuaternion);

                    // Rotate around LOCAL Z-axis (which is the face normal after base orientation)
                    // This makes the arrow circulate WITHIN the face plane, not rotate as a 3D object
                    const angle = state3d.rotationAngle * direction;

                    // Use rotateOnAxis with local Z to rotate in the face plane
                    arrowGroup.rotateOnAxis(new THREE.Vector3(0, 0, 1), angle);
                });

                renderer.render(scene, camera);
            } catch (error) {
                console.error('Animation error:', error);
            }

            requestAnimationFrame(animate3D);
        }

        function get3DMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse3d.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse3d.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function on3DMouseDown(event) {
            if (event.button === 2) { // Right click for rotation
                isRotating3d = true;
                previousMouse = { x: event.clientX, y: event.clientY };
                renderer.domElement.style.cursor = 'grabbing';
            } else { // Left click for dragging
                get3DMousePosition(event);
                raycaster.setFromCamera(mouse3d, camera);

                const intersects = raycaster.intersectObjects([
                    spheres3d.u, spheres3d.v, spheres3d.w
                ]);

                if (intersects.length > 0) {
                    dragging3d = intersects[0].object.userData.vector;
                    renderer.domElement.style.cursor = 'grabbing';
                }
            }
        }

        function on3DMouseMove(event) {
            if (isRotating3d) {
                const deltaX = event.clientX - previousMouse.x;
                const deltaY = event.clientY - previousMouse.y;

                // Rotate camera around origin
                const rotationSpeed = 0.005;

                const radius = Math.sqrt(
                    camera.position.x * camera.position.x +
                    camera.position.y * camera.position.y +
                    camera.position.z * camera.position.z
                );

                const polar = Math.acos(camera.position.y / radius);
                const azimuth = Math.atan2(camera.position.z, camera.position.x);

                const newAzimuth = azimuth + deltaX * rotationSpeed;
                const newPolar = Math.max(0.1, Math.min(Math.PI - 0.1, polar - deltaY * rotationSpeed));

                camera.position.x = radius * Math.sin(newPolar) * Math.cos(newAzimuth);
                camera.position.y = radius * Math.cos(newPolar);
                camera.position.z = radius * Math.sin(newPolar) * Math.sin(newAzimuth);

                camera.lookAt(0, 0, 0);

                previousMouse = { x: event.clientX, y: event.clientY };
            } else if (dragging3d) {
                get3DMousePosition(event);
                raycaster.setFromCamera(mouse3d, camera);

                // Project onto multiple planes and pick the best one
                const originalVector = state3d[dragging3d].clone();

                // Try projecting onto XY, XZ, and YZ planes
                const planes = [
                    new THREE.Plane(new THREE.Vector3(0, 0, 1), 0), // XY plane
                    new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), // XZ plane
                    new THREE.Plane(new THREE.Vector3(1, 0, 0), 0)  // YZ plane
                ];

                let bestPoint = null;
                let bestDistance = Infinity;

                planes.forEach(plane => {
                    const intersectPoint = new THREE.Vector3();
                    const intersects = raycaster.ray.intersectPlane(plane, intersectPoint);

                    if (intersects) {
                        const distance = intersectPoint.distanceTo(originalVector);
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestPoint = intersectPoint;
                        }
                    }
                });

                if (bestPoint) {
                    updateVector3D(dragging3d, bestPoint);
                }
            } else {
                // Hover effect
                get3DMousePosition(event);
                raycaster.setFromCamera(mouse3d, camera);

                const intersects = raycaster.intersectObjects([
                    spheres3d.u, spheres3d.v, spheres3d.w
                ]);

                renderer.domElement.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
            }
        }

        function on3DMouseUp() {
            isRotating3d = false;
            dragging3d = null;
            renderer.domElement.style.cursor = 'default';
        }

        function on3DWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.1;
            const delta = event.deltaY * zoomSpeed;

            const direction = camera.position.clone().normalize();
            camera.position.addScaledVector(direction, delta);

            // Limit zoom
            const dist = camera.position.length();
            if (dist < 3) {
                camera.position.normalize().multiplyScalar(3);
            } else if (dist > 20) {
                camera.position.normalize().multiplyScalar(20);
            }
        }

        function on3DTouchStart(event) {
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                on3DMouseDown({
                    button: 0,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            } else if (event.touches.length === 2) {
                isRotating3d = true;
                const touch = event.touches[0];
                previousMouse = { x: touch.clientX, y: touch.clientY };
            }
        }

        function on3DTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                on3DMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
            } else if (event.touches.length === 2 && isRotating3d) {
                const touch = event.touches[0];
                on3DMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
            }
        }

        function on3DTouchEnd(event) {
            on3DMouseUp();
        }

        function onWindowResize() {
            if (currentMode === '2d') {
                resizeCanvas();
            } else if (renderer) {
                const rect = container3d.getBoundingClientRect();
                camera.aspect = rect.width / 500;
                camera.updateProjectionMatrix();
                renderer.setSize(rect.width, 500);
            }
        }

        // ============= MODE SWITCHING =============
        document.querySelectorAll('.dimension-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.dimension-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const newMode = btn.dataset.mode;

                if (newMode === '2d') {
                    currentMode = '2d';
                    canvas2d.style.display = 'block';
                    container3d.style.display = 'none';
                    document.getElementById('instructionTitle').textContent = 'How to use (2D Mode)';
                    document.getElementById('instructionText').textContent = 'Drag the circular endpoints to adjust vectors u and v. The bivector and orientation arrow update in real-time.';
                    document.getElementById('magnitudeLabel').textContent = 'Area';
                    document.getElementById('operationButtons').style.display = 'grid';
                    document.getElementById('explanation2d').style.display = 'block';
                    document.getElementById('explanation3d').style.display = 'none';
                    resizeCanvas();
                    draw2d();
                } else {
                    currentMode = '3d';
                    canvas2d.style.display = 'none';
                    container3d.style.display = 'block';
                    document.getElementById('instructionTitle').textContent = 'How to use (3D Mode)';
                    document.getElementById('instructionText').textContent = 'Drag colored spheres to adjust vectors. Right-click and drag (or two-finger drag on mobile) to rotate camera. Scroll to zoom.';
                    document.getElementById('magnitudeLabel').textContent = 'Volume';
                    document.getElementById('operationButtons').style.display = 'none';
                    document.getElementById('explanation2d').style.display = 'none';
                    document.getElementById('explanation3d').style.display = 'block';

                    // Initialize 3D if not already done
                    if (!scene) {
                        // Wait for Three.js to load
                        if (typeof THREE !== 'undefined') {
                            init3D();
                            animate3D();
                        } else {
                            console.error('Three.js not loaded');
                            alert('3D mode requires Three.js to load. Please refresh the page.');
                        }
                    } else {
                        onWindowResize();
                        animate3D();
                    }
                }
            });
        });

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state2d.mode = btn.dataset.mode;
            });
        });

        // Initialize 2D mode on load
        window.addEventListener('load', () => {
            resizeCanvas();
            draw2d();
        });

        window.addEventListener('resize', onWindowResize);
    </script>
</body>
</html>